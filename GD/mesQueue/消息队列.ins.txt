在获取消息队列的函数msgget中int msgget(key_t key, int msgflg)中
参数：
     key：是一个消息对了标志。
     msgflg：IPC_CREAT值，若没有该队列，则创建一个并返回新标识符；若已存在，则返回原标识符。

             　  IPC_EXCL值，若没有该队列，则返回-1；若已存在，则返回0。

在向消息队列写消息的程序snd.c中：
使用IPC_CREAT，表示如果没有将建立一个消息队列，而在rcv.c中使用了IPC_EXCL。
所以应该先启动snd.c程序。

对消息队列的处理包括：
msgrcv从队列中取用消息：ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
msgsnd将数据放到消息队列中：int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
参数：
     msqid：消息队列的标识码
     msgp：指向消息缓冲区的指针，此位置用来暂时存储发送和接收的消息，是一个用户可定义的通用结构，形态如下： 
这定义如下：
struct my_msg_st {
	long int my_msg_type;
	char some_text[MAX_TEXT];
};
     msgsz：消息的大小。
     msgtyp：从消息队列内读取的消息形态。如果值为零，则表示消息队列中的所有消息都会被读取。
　　msgflg：用来指明核心程序在队列没有数据的情况下所应采取的行动。如果msgflg和常数IPC_NOWAIT合用，则在msgsnd()执行时若是消息队列已满，则msgsnd()将不会阻塞，而会立即返回-1，如果执行的是msgrcv()，则在消息队列呈空时，不做等待马上返回-1，并设定错误码为ENOMSG。当msgflg为0时，msgsnd()及msgrcv()在队列呈满或呈空的情形时，采取阻塞等待的处理模式。


在snd.c中
some_data.my_msg_type 的初始值为10，每发一个消息（some_data.my_msg_type =
i--;）自动减一，
在rcv.c中
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int
msgflg);
msgsz设置为：-8。表示，将返回消息队列中消息类型值小于或等于-8的绝对值的消息，
所以在rcv.c中的前两个消息是接收不到的。

