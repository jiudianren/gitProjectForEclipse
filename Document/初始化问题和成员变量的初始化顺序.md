#内置类型 
 未被显式初始化。则其值，由位置决定，函数外的 被初始化为0 ，函数内的则是未定义。


http://www.cnblogs.com/Murcielago/p/4187567.html
有些成员变量的数据类型比较特别，它们的初始化方式也和普通数据类型的成员变量有所不同。这些特殊的类型的成员变量包括：

	a.引用
	b.常量
	c.静态
	d.静态常量(整型)
	e.静态常量(非整型)

  
	常量和引用，和没够默认构造函数的类类型成员，必须通过参数列表进行初始化。


静态成员变量的初始化也有点特别，是在类外初始化且不能再带有static关键字。

静态成员属于类作用域，但不属于类对象，和普通的static变量一样，程序一运行就分配内存并初始化，生命周期和程序一致。  
可以这么理解：
在类中，只是声明了静态变量，并没有定义。而恰恰是因为仅仅做了声明，所以并不为其分配内存，只有当定义了以后才分配内存。  
(注意：如果在类里面这么写: int a; 那么是既声明了变量，也定义了变量，两者合在一起了。)

 
静态成员其实和全局变量地位是一样的，是“类级别”的，也就是它和类的地位相同，只不过编译器把它的使用限制在类作用域内（不是类对象，它不属于类对象成员），要在类的定义外（不是类作用域外）初始化。而普通成员是“对象级别”的。类级别的成员，先于该类任何对象的存在而存在，它被该类所有的对象共享。

 

所以，在类的构造函数里初始化static变量显然是不合理的。
假定要实例化该类的一个对象，那么会发生什么事情呢？静态成员肯定要出现在这个对象里面的。
这时候才去定义那个静态成员吗？这显然是不合适的。因为，比如有另外一个线程也要创建该类的对象，那么也要按照这个方式去定义那个静态成员。这会产生两种可能的情况：1. 重复定义；2. 就算不产生重复定义的情况，也会产生竞争，从而造成死锁的问题，以至于对象无法创建。很显然，编译器不能这么干。那么很合理的解决办法，就是事先在类的外部把它定义好，然后再供所有的对象共享。



初始化可以分为两个阶段:

	1 初始化阶段
	2 普通计算阶段（构造函数执行体）

	不管成员是否在构造函数初始化列表中，类类型的成员总在初始化阶段初始化
	
	
内置类型或者复合类型 （如指针，数组 ）的成员的初始化依赖于对象的作用域：
局部作用域中，这些成员不被初始化，全局变量，会被初始化为0.

成员初始化的次序：
		
		成员初始化的次序通常无关紧要：但如果一个成员的是根据其他成员而初始化的，则初始化顺序相当重要。
		

《c++ primer 第四版本 12.4 构造函数》


	class A
	{
		private:
			int n1;
			int n2
		public:
		A():n2(0),n1(n2+2)
		{
		}
		
		void Print
		{
			cout<< n1 <<n2 ;
		}
	}

输出： n1 不确定 ，n2 0

原因，初始化顺序，只和声明顺序有关， 先初始化n1 ,因为n1=n2+2, 初始化n2,n2初始化也不固定，所以 n1的值不固定

接着初始化n2 n2初始化为0 ，得出答案。

