

http://note.youdao.com/noteshare?id=accc28c56b127c1c28efa6655b145fe4&sub=8E22308B2949472DB18D1212D9895176

## 网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？
答:若客户端掉线或者重新启动，服务器端会收到复位信号，每一种tcp/ip得实现不一样，控制机制也不一样。

 #非阻塞connect（）如何实现？ ？？
将socket设置成non-blocking，操作方法同非阻塞read()、write();

##TTL是Time To Live，一般是hup count，每经过一个路由就会被减去一，如果它变成0，包会被丢掉。它的主要目的是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute用到它。

详:TTL是Time To Live，目前是hup count，当包每经过一个路由器它就会被减去一，如果它变成0，路由器就会把包丢掉。IP网络往往带有环(loop)，比如子网A和子网B有两个路由器相连，它就是一个loop。

    TTL的主要目的是防止包在有回路的网络上死转，
因为包的TTL最终后变成0而使得此包从网上消失(此时往往路由器会送一个ICMP包回来，traceroute就是根据这个做的)。ping会送包出去，所以里面有它，但是ping不一定非要不可它。traceroute则是完全因为有它才能成的。ifconfig是用来配置网卡的，netstat -rn 是用来列路由表的，所以都用不着它

## struct和union的区别
struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。

对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。



##什么是“引用”？声明和使用“引用”要注意哪些问题？

         引用的特性：

                 引用是目标变量的别名，对引用的操作与对变量的操作效果一样。声明引用的时候要必须对其初始化。引用声明完后，相当于目标变量有两个名称，不能  　　 再把引用作为其他变量的别名。

                 引用不是新定义一个变量，它只是表示该引用是目标变量名的一个别名，它本身不是一种数据类型，因此引用不占用存储单元。

                 无法建立数组的引用。因为数组是一个由若干元素组成的集合，无法建立数组的别名。

         引用的作用：

                 作为函数的参数，以前用值传递，现在用指针或引用。

                 传引用和传指针给函数效果一样的。

                 传递引用，内存中没有生成实参副本，是直接对实参操作。如果传递的是值类型，需要在栈上生成副本，如果是对象，还要调用构造函数。

                  指针调用的时候，其实也会形参分配存储单元，且需要用“指针变量名”的形式运算，容易产生错误并且可读性差；调用的时候，需要用变量的地址作为实             参，调用形式不好看。引用没有这些            问题。

                  引用作为返回值最大的好处是：内存中不会产生副本。

                  但是，引用作为返回值注意事项：

                  A：不能返回局部变量的引用。

                  B：不能返回函数内部new的变量。因为引用仅仅是别名，无法释放内存。

                  C: 可以返回类成员的引用，但是最好是const

                  D : 引用和指针一样，可以产生多态的效果。

   总结：    

             A: 引用的使用主要用于函数传参，解决大块数据或对象的问题。
             B： 用引用传递函数参数，不产生副本，通过const，保证引用传递的安全性。
             C：比指针的可读性好，
## socket在什么情况下可读?
1. 接收缓冲区有数据，一定可读
2. 对方正常关闭socket，也是可读 
3. 对于侦听socket，有新连接到达也可读
4.socket有错误发生，且pending～～～

#网络编程的一般步骤

对于TCP连接：
1.服务器端1）创建套接字create；2）绑定端口号bind；3）监听连接listen；4）接受连接请求accept，并返回新的套接字；5）用新返回的套接字recv/send；6）关闭套接字。

2.客户端1）创建套接字create; 2）发起建立连接请求connect; 3）发送/接收数据send/recv；4）关闭套接字。

TCP总结：

Server端：create -- bind -- listen--  accept--  recv/send-- close
Client端：create------- conncet------send/recv------close.



对于UDP连接：
1.服务器端:1）创建套接字create；2）绑定端口号bind；3）接收/发送消息recvfrom/sendto；4）关闭套接字。
2.客户端:1）创建套接字create；2）发送/接收消息sendto/recvfrom；3）关闭套接字.
UDP总结:
Server端：create----bind ----recvfrom/sendto----close

Client端：create----  sendto/recvfrom----close.

#TCP的流量控制和拥塞控制
https://blog.csdn.net/yechaodechuntian/article/details/25429143


#找出1-10w中没有出现的两个数字。
1） 位图，申请10w个bit的空间，每个bit代表一个数字是否出现过。开始时将这10w个bit都初始化为0，表示所有数字都没有出现过。然后依次读入已经打乱循序的数字，并将对应的bit设为1。当处理完所有数字后，根据为0的bit得出没有出现的数字。

2） 首先计算1到10w的和，平方和。然后计算给定数字的和，平方和。两次的到的数字相减，可以得到这两个数字的和，平方和。所以我们有x + y = n x^2 + y^2 = m 解方程可以得到x和y的值。


# fork()一子进程程后 父进程m全局变量能不能使用？？？
fork后子进程将会拥有父进程的几乎一切资源，父子进程的都各自有自己的全局变量。不能通用，不同于线程。对于线程，各个线程共享全局变量。

# const的含义及实现机制，比如：const int i,是怎么做到i只可读的？
http://blog.csdn.net/fycy2010/article/details/48199951
 const指示对象为常量，只读。
实现机制：这些在编译期间完成，对于内置类型，如int， 编译器可能使用常数直接替换掉对此变量的引用。而对于结构体不一定。
看下面的例子：
#offsetof
https://zh.wikipedia.org/wiki/Offsetof
http://xiva.iteye.com/blog/1176115
https://www.jianshu.com/p/73778bddf4c2

#100亿个数，求最大的1万个数，并说出算法的时间复杂度。
用小根堆来实现。注意是小根堆，
读入1万个数，然后做
时间复杂度是O（NlogK）

##小根堆 大根堆

#cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握

top

df 
du 


free查看内存 

https://www.cnblogs.com/zhuiluoyu/p/6154898.html

/proc/meminfo

#对端关闭，可读，read 返回 0，表示已经读到文件末尾。

read返回0的唯一条件是对方gracefully close了socket
select ＞ 0，表示套接字里有东西，
read ＝ 0，表示里面的东西是“对方关闭连接”。
当select出错时，会将接口置为可读又可写。这时就要通过判断select的返回值为-1来区分。


# 多线程和多进程的区别

（重点 面试官最最关心的一个问题，
必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，
然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）  

#写一个c程序辨别系统是16位还是32位


2位处理器就是一次只能处理32位，也就是4个字节的数据，虚拟地址空间的最大大小是4G，而64位处理一次就能处理64位，即8个字节的数据，最大虚拟地址空间的最大大小是

16T。

最明显的是指针大小的变化，32位系统指针是32位，64位系统指针是64位。
其他的，int都是32位，short都是16位，long 32位系统是32位，64位系统为64位，
size_t ssize_t 32位系统为32位，64位系统为64位。


判断方法：



	#include "stdio.h"    
	    
	int main(int argc,char * argv[])    
	{    
	    void* number =  0;    
	    printf("%d\n",sizeof(&number));    
	}  



#i++是否原子操作？并解释为什么？

1.i++分为三个阶段：

内存到寄存器
寄存器自增
写回内存
这三个阶段中间都可以被中断分离开.

#delete 和 delete []

#进程退出exit，_exit区别即atexit函数


https://www.cnblogs.com/mickole/p/3186606.html


#Linux内存管理
https://blog.csdn.net/hustyangju/article/details/46330259
#如何实现守护进程？
https://blog.csdn.net/qq_26499321/article/details/72724173
守护进程之编程规则 
（1）首先要做的是调用umask将文件模式创建屏蔽字设置为0。 
　　文件权限掩码：是指屏蔽掉文件权限中的对应位。例如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限（对应二进制为，rwx, 101）。由于fork函数创建的子进程继承了父进程的文件权限掩码，这就给子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0（即，不屏蔽任何权限），可以增强该守护进程的灵活性。设置文件权限掩码的函数是umask。通常的使用方法为umask(0)。

（2）调用fork，然后使父进程退出（exit）。if(pid=fork()) exit(0);

（3）调用setsid以创建一个新会话，脱离控制终端和进程组。setsid函数作用：用于创建一个新的会话，并担任该会话组的组长。 

　　调用setsid有3个作用：(a) 让进程摆脱原会话的控制；(b) 让进程摆脱原进程组的控制；(c) 让进程摆脱原控制终端的控制； setsid() 
　　使用setsid函数的目的：由于创建守护进程的第一步调用了fork函数来创建子进程再将父进程退出。由于在调用fork函数时，子进程拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开了。使用setsid函数后，能够使进程完全独立出来，从而摆脱其他进程的控制。

（4）将当前工作目录更改为根目录。#define NOFILE 256 for(i=0;i<NOFILE;i++) close(i);

（5）关闭不再需要的文件描述符。这使守护进程不再持有从其父进程继承来的某些文件描述符（父进程可能是shell进程，或某个其他进程）。

（6）某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出和标准出错的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以不能在终端设备上显示其输出，也无处从交互式用户那里接受输入。


#不用第三个变量，直接交换两个变量的值
方法一：
var a=1;
var b=2;
a=a+b;
b=a-b;
a=a-b;
输出a,b可以发现两值已经交换

 

方法二：
var a=1;
var b=2;
a=a^b;
b=a^b;
a=a^b;
输出a,b可以发现两值已经交换

# 判断系统是大端还是小端
大端模式：字数据的高字节存储在低地址中，字数据的低字节存放在高地址中。big endian
小端模式：字数据的高字节存储在高地址中，字数据的低字节存放在低地址中。little endian
1、直接判断内存的存储情况
	
	// 1: Little Endian; 0: Big Endian.
	int isLittleEndian(void) 
	{ 
	    int i = 0x12345678; 
	    char *c = (char *)&i; 
	    return ((c[0] == 0x78) && (c[1] == 0x56) && (c[2] == 0x34) && (c[3] == 0x12)); 
	}
2、用union方法判断

	typedef union {
	    int i;
	    char c;
	} myUnion;
	// 1: Little Endian; 0: Big Endian.
	int isLittleEndian02(void)
	{
	    myUnion u;
	    u.i = 1;
	    return (u.i == u.c);
	}
读取成员c就相当于是读取成员a的低位的第一个字节值。
小端模式：u.i = 1，则a的最低位字节为1，成员c的位置也是内存的最低位字节，所以u.i等于u.c等于1。

#面对对象编程的 三个基本特征

面向对象的三个基本特征是：封装、继承、多态。
# TCP通讯中，select到读事件，但是读到的数据量是0，为什么，如何解决????
select 返回0代表超时。select出错返回-1。

select到读事件，但是读到的数据量为0，说明对方已经关闭了socket的读端。本端关闭读即可。

当select出错时，会将接口置为可读又可写。这时就要通过判断select的返回值为-1来区分。

#  给出float与“零值”比较的 if 语句（假设变量名为var）？？？
const float EPSINON = 0.00001;
  if ((x >= - EPSINON) && (x <= EPSINON)

浮点数在内存中的存贮机制和整型数不同，有舍入误差，在计算机中用以近似表示任意某个实数。
具体的说，这个实数由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到，这种表示方法类似于基数为10的科学记数法。
  所以浮点数在运算过成功运算通常伴随着因为无法精确表示而进行的近似或舍入。但是这种设计的好处是可以在固定的长度上存储更大范围的数。
  例如，一个指数范围为±4的4位十进制浮点数可以用来表示43210，4.321或0.0004321，但是没有足够的精度来表示432.123和43212.3（必须近似为432.1和43210）。当然，实际使用的位数通常远大于4。  
  所以浮点数不能够判断相等，像 if(x==0)的这样的编码是不总是正确的，我们在判断浮点数相等时，推荐用范围来确定，若x在某一范围内，我们就认为相等，至于范围怎么定义，要看实际情况而已了，float,和double 各有不同
  所以const float EPSINON = 0.00001;  
  if ((x >= - EPSINON) && (x <= EPSINON) 这样判断是可取的
  至于为什么取0.00001，可以自己按实际情况定义

#有千万个string在内存怎么高速查找，插入和删除？？？
对千万个string做hash，可以实现高速查找，找到了，插入和删除就很方便了。
关键是如何做hash，对string做hash，要减少碰撞频率。

#volatile的含义。
变量可能在编译器的控制或监控之外改变，告诉编译器不要优化该变量，如被系统时钟更新的变量



# override和overload的区别。
 Overload是重载的意思，Override是覆盖的意思，也就是重写。

    重载Overload：在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。

    重载的特点：与返回值类型无关，只看参数列表。

    重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中定义的方法，这相当于把父类中定义的那个完全相同的方法给覆盖掉了，这也是面向对象编程的多态的一种表现。子类覆盖父类方法时只能抛出父类的异常或者异常的子类或者父类异常的子集，因为子类可以解决父类的一些问题，但不能比父类有更多的问题。还有，子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，则子类中根本不存在覆盖，即子类中和父类的private的同名的方法没有覆盖的关系，因为private的访问权限只限于同一类中，而子类就不会访问到private的方法，所以是子类中增加的一个全新的方法。

    重载overload的特点就是与返回值无关，只看参数列表，所以重载的方法是可以改变返回值类型的。所以，如果两个方法的参数列表完全一样，是不能通过让他们的返回值类型不同来实现重载的。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。


技术类
①百度2015校园招聘技术类面试题
一面（1 hour）：
1. 面试官从简历里抽了一个较感兴趣的项目，让把项目简单介绍了下，针对项目问了几个技术问题

3. 数据库隔离级别介绍、举例说明。
5. 求二叉树的最大距离（即相距最远的两个叶子节点），写代码。

7. 你觉得你的优势是什么？有什么技术薄弱点吗？
8. 目前手上有offer吗？
二面（40 minutes）：
1. 详细介绍研究生期间的小论文项目。


3. Hashmap、Hashtable和cocurrentHashMap的区别，要讲出它们各自的实现原理才行，比如Hashmap的扩容机制、cocurrentHashMap的桶分割原理、多线程安全性。
4. 进程调度算法，有哪些算法比较难实现？
5. linux下如何修改进程优先级？（nice命令的使用）。
6. linux下性能监控命令uptime介绍，平均负载的具体含义是什么？建议看server load概念。

三面（1 hour and twenty minutes）：

2. 字符串中第一个只出现一次的字符，如何优化算法使得遍历次数更少？

3. socket编程相关，如果服务器这边调用write写了100个字节的数据，客户端想要获得这个数据，是直接用read系统调用，参数也是100吗？
4. 百度新闻缓存预算问题：一般为了追求时间性能，都需要缓存一些新闻数据，你怎么计算所需预算？然后申请需要的主机……
5. 多线程的适用场景是什么？为什么要用多线程？

7. 为什么对技术感兴趣，一些相关问题讨论。

②百度技术类面试题
1、实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。
例子：
func(7) = 4，可以证明最少需要4次运算
n = 7
n-1 6
n/2 3
n-1 2
n/2 1
要求：实现函数(实现尽可能高效) int func(unsign int n)；n为输入，返回最小的运算次数。给出思路(文字描述)，完成代码，并分析你算法的时间复杂度。
2、找到满足条件的数组
给定函数d(n)=n+n的各位之和，n为正整数，如d(78)=78+7+8=93。这样这个函数可以看成一个生成器，如93可以看成由78生成。
定义数A：数A找不到一个数B可以由d(B)=A，即A不能由其他数生成。现在要写程序，找出1至10000里的所有符合数A定义的数。
3、一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL。
4、海量日志数据，提取出某日访问百度次数最多的那个IP。
5、有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？
6、蚂蚁爬杆问题
有一根27厘米长的细木杆，在第3厘米，7厘米，11厘米，17厘米，23厘米这五个位置上各有一只蚂蚁，木杆很细，不能同时通过两只蚂蚁，开始时，蚂蚁的头朝向左还是右是任意的，他们只会朝前走或掉头，但不会后退，当两只蚂蚁相遇后，蚂蚁会同时掉头朝反方向走，假设蚂蚁们每秒钟可以走1厘米的距离。求所有蚂蚁都离开木杆的最小时间和最大时间。
7、当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？
8、判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度。
9、三个警察和三个囚徒的过河问题
三个警察和三个囚徒共同旅行。一条河挡住了去路，河边有一条船，但是每次只能载2人。存在如下的危险：无论在河的哪边，当囚徒人数多于警察的人数时，将有警察被囚徒杀死。问题：请问如何确定渡河方案，才能保证6人安全无损的过河。
10、从300万字符串中找到最热门的10条
搜索的输入信息是一个字符串，统计300万输入信息中的最热门的前10条，我们每次输入的一个字符串为不超过255byte，内存使用只有1G。请描述思想，写出算法（c语言），空间和时间复杂度。
11、如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？
12、找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。
13、找出被修改过的数字
n个空间（其中n<1M），存放a到a+n-1的数，位置随机且数字不重复，a为正且未知。现在第一个空间的数被误设置为-1。已经知道被修改的数不是最小的。请找出被修改的数字是多少。
14、设计DNS服务器中cache的数据结构。
要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）
15、找出给定字符串对应的序号。
序列Seq=[a,b,…z,aa,ab…az,ba,bb,…bz,…,za,zb,…zz,aaa,…]类似与excel的排列，任意给出一个字符串s=[a-z]+(由a-z字符组成的任意长度字符串），请问s是序列Seq的第几个。
16、找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。
17、给40亿个不重复的unsigned int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中?
18、在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。
19、时分秒针在一天之类重合多少次？（24小时）
20、将多个集合合并成没有交集的集合。
给定一个字符串的集合，格式如：{aaabbbccc}，{bbbddd}，{eeefff}，{ggg}，{dddhhh}要求将其中交集不为空的集合合并，要求合并完成后的集合之间无交集，例如上例应输出{aaabbbcccdddhhh}，{eeefff}，{ggg}。
（1）请描述你解决这个问题的思路；
（2）请给出主要的处理流程，算法，以及算法的复杂度
（3）请描述可能的改进。
21、平面内有11个点，由它们连成48条不同的直，由这些点可连成多少个三角形？

③百度运维部笔试题
第一部分・简答
1.简述树的深度优先算法、广度优先算法，及非递归实现的特点。
2.在文件系统中，元数据（比如ext2中的inode）的基本作用是什么？ext2跟ext3的根本区别是什么？
3.在web服务中，负载均衡的基本作用是什么？请举例你熟悉的一款负载均衡软件或者实现方案，简述它们的实现原理。（这题后半部分为开放性，我也没记多深，大概就这样）
4.数据库事务的四大特性是什么？请你简单举例对一个完全不懂数据库的人解释这四个特性。投数据库管理员（DBA）必答。
5.一个微型处理器，1KB内存和1MHz（每MHz运算次数为10^6），在这样的计算机上面运行程序（程序到该终止时会自动终止，不会出现死循环）最长能运行多长时间？你可以进行任何需要的假定。
第二部分・算法和程序设计
1.int maxContinuNum(const char *inputstr,char * outputstr)
编写一段程序实现该函数，实现返回一个以“\0”结束的字符串中最长的数字串的长度，并把该数字子串的首地址赋给outputstr。不能使用任何库函数或已经存在的函数，如strlen。
例如：在字符串“abc123abcdef12345abcdefgh123456789”中，把该字符串的首地址赋给inputstr，返回9，outputstr指向字符串“123456789”的首地址。
第三部分为备份系统设计，设计一个备份系统，要求符合三个备份场景，写出你的设计思路，框架模块设计，实现原理。
要求：
1.该系统要能实现对多服务器备份工作（大概这样，还是。。）
2.该系统要具备很好容错性，不能因为多服务器中的一台出现故障儿导致整个备份工作不能进行。
5.具有较强的扩展性，例如当服务器内存不够时，能灵活的添加内存。
扩展性是附加，在实现前面的要求后再考虑扩展性
其他要求暂未找到
④百度商务搜索笔试题
1、深度优先，广度优先定义。它们非递归实现的特点
2、一个复数实部虚部分别相乘求和的程序改错
3、一个有内存1KB，处理器速度 10^6／S
4、N个文件相互有倚赖（编译的时候）设计一个算法，编译
5、一个字符串中最长的数字子串
6、100亿个URL的存储，查找，删除，更新，添加
⑤百度技术类面试题1
一面
1.网络编程经验：
如何判断一个http请求，一个客户端请求已经结束；如何处理服务器多线程，获得一个http请求后，是如何处理的？返回什么？有没有试过返回图片？服务器给客户端请求时，是用什么函数写？服务器如何获取客户端请求，用什么函数
2.cv操作是什么函数 cv_init, cv_wait, cv_signal
3.有一些关键词点击次数的文件，如何输出最多点击的一百个

5.有些文件，频繁访问在磁盘里头的，现在要放到内存中了。采用什么策略来决定哪些放到内存中？如果是一些url文件，放在内存后，如何快速的找到某个url的位置，如何快速找到哪些文件太久没人访问了，把他替换出去？
6.c语言相关：内联函数的好处？非内联函数被调用的过程是怎么样的？int,short,char的struct，这几个数应该怎么放，内存小？怎么防止头文件被include多次？
7.有没有什么问题想问的
8.linux网络查看的命令
二面
1.介绍一个项目
2.2.5亿个int数，可能有相同的。统计出这里头不同的数有多少个？只有2g内存。（2.5*1000 000 000 * 4 =1G）
答：把key作为连续的（就是hash是稀疏的，有个key值没有存在这2.5亿个数中），像数组下标一样，那么要访问第n个数，直接到第n个去看，复杂度是O(1)
但是，如果连续，2.5亿个数，范围很广，而每个key用int存，会很大量，内存不一定够。 解决方案：每个key用一位bit来标志。即数字1放在第一个bit上，数字2放在第二个bit上。看第n位在不在，就找一下第n个bit是1，还是0
具体方法：char a[] 数组。假设找3，那么3在3/8--0...3,所以在a[0]中，找第3个bit，如果是0，就设置为1。最后看看a[]的二进制表示有多少个1就有多少个数
3. 海量数据，在mysql中，cpu占用率很高。如何解决？
答：1.show processlist，看哪个sql查询的多，建索引（问：建立联合索引时，要考虑什么，怎么建（哪个在前，哪个列在后？）
2.如果老是在拷贝到临时表，就改配置，把临时表内存改大些
3.还有什么方法：
1）分布式数据库 （问：如果你来设计分布式数据库，你会怎么设计？）
2）使用缓存 （问：如果缓存中的数据，被删除或跟新了，数据库怎么判断这个缓存的数据不能用了，是脏数据？）（不懂）
问：什么情况下cpu会高？（内存不足）为什么内存不足cpu会高（频繁io读写）
4.n个无序int，（有正有负），给一个数v，如何找出其中的a+b=v的两个数
答：排序 O(nlogn)，记录序列中，0，大于v，小于v的3位。尝试最小的和最大的，最大不行，次大，找到某个，加起来小于v了，停止尝试次小的，从上次大头停止的位置开始尝试 ---尝试范围两头不断缩小，复杂度为n）
5.网络相册，一个人可以有多个相册，一个相册有多个图片，如何快速实现增删查移动等操作。web页面上，图片是翻页显示。
答：数据库记录：usr_id, book_id, item_id, position。相片放在磁盘上，目录为position/usr_id/book_id/item_id
一次查两个操作：1）数据库查找2）根据位置取图片
如果用户提取某个相册的所有图片，先给他第一个相片和所有item_id列表。然后用户翻页了，在客户端通过javascript能够知道翻的是哪个item，把item_id，book_id, usr_id发给服务器，服务器根据这个到目录下去找
6.Unix系统里，一个简单的print hello world的c程序，从./a.out执行到屏幕打印出来这句话，是什么过程
7.socket编程，要注意什么问题
答：服务器的serversocket的基本模型。
但是大量请求，会不能及时响应。所以要多线程。 一个监听线程，多个服务线程。服务线程一开始起来都阻塞在存放请求socket的tasklist上。wait
监听线程接受到client的socket，放入tasklist中，signal唤醒一个服务线程。服务线程处理它，并把它从list中移走
三面
1.fread的过程
3.主DB在接到数据更新后同步到后台DB，如何避免网络丢失之类的问题
答：1：传的是sql语句，接到后回ack，如果主DB发现一段时间没有回，重发；其实TCP传输，就保证了不会漏数据，所以不会考虑这个问题的）
2：每次传sql语句和当前版本号，然后后台DB会对比版本号是不是正确，发现落后就发数据请求。主DB保留每次版本号更新关联的sql语句） 4. N个bit，如和判断其中有多少个1.（时间复杂度小于N） 预存一个2的8次方大小的数组，每个数组值是，这个下标的数的二进制的1的个数，例如： a[0]=0, a[1]=1, a[2]=1,a[3]=2....a[2^8-1]=7 （以空间换时间）
然后一个byte一个byte的读，看看他的值，直接以这个值为下标去数组看他的1的个数
另一个方法：
while(v){ v &= (v-1); num++; }
1000 & 0111 = 0, 所以每&一次，不为0，说明有1个1，&到为0为止，num就是1的个数。复杂度为1的个数。
⑥百度技术类面试题2
1、介绍一下项目。
2、上千万条记录，统计出重复记录最多的前N条。
3、54张扑克牌，除去两张大小王剩下52张扑克牌。问红桃A和黑桃A同时被一个人拿到的概率是多少?
4、多个线程访问共享内存时因该怎么办?
5、在写程序遇到问题的时候，通常采用什么调试方法?
6、client/server的协议问题
7、优缺点、期望工作的性质、职业规划等