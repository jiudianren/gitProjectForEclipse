《Cpp Concurrency In Action》

本书相关
github 翻译地址：https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action
gitbook 在线阅读：http://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/
书中源码：https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action
学习C++11/14: http://www.bogotobogo.com/cplusplus/C11

# 1

## 1.1
什么是并发
并发的途径  进程并发 线程并发

进程并发和线程并发的区别

## 1.2 为什么使用并发

主要原因有两个：关注点分离(SOC)和性能。事实上，它们应该是使用并发的唯一原因；如果
你观察得足够仔细，所有因素都可以归结到其中的一个原因(或者可能是两个都有。当然，除
了像“就因为我愿意”这样的原因之外)。

## 1.2 为什么不使用并发
基本上，不使用并发的唯一原因就是，收益比不上成本


## 1.4 入门



##2.1.1
启动了线程，你需要明确是要等待线程结束(加入式――参见2.1.2节)，还是让其自主运行(分
离式――参见2.1.3节)。如果 std::thread 对象销毁之前还没有做出决定，程序就会终止
( std::thread 的析构函数会调用 std::terminate() )。因此，即便是有异常存在，也需要确保
线程能够正确的加入(joined)或分离(detached)。2.1.3节中，会介绍对应的方法来处理这两种
情况。需要注意的是，必须在 std::thread 对象销毁之前做出决定，否则你的程序将会终止
(std::thread的析构函数会调用std::terminate()，这时再去决定会触发相应异常)。

##2.1.3

##2.1.4

通常称分离线程为守护线程(daemon threads),UNIX中守护线程是指，没有任何显式的用户接
口，并在后台运行的线程。这种线程的特点就是长时间运行；线程的生命周期可能会从某一
个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结
构进行优化。另一方面，分离线程的另一方面只能确定线程什么时候结束，发后即忘(fire and
forget)的任务就使用到线程的这种方式


这个例子也展示了传参启动线程的方法：不仅可以向 std::thread 构造函数①传递函数名，还
可以传递函数所需的参数(实参)。C++线程库的方式也不是很复杂。当然，也有其他方法完成
这项功能，比如:使用一个带有数据成员的成员函数，代替一个需要传参的普通函数。

##2.2 线程传参


期望传递一个引用，但整个对象被复制了

标准线程库中和 std::unique_ptr 在所属权上有相似语义类型的类有好几种， std::thread 为
其中之一。虽然， std::thread 实例不像 std::unique_ptr 那样能占有一个动态对象的所有
权，但是它能占有其他资源：每个实例都负责管理一个执行线程。执行线程的所有权可以在
多个 std::thread 实例中互相转移，这是依赖于 std::thread 实例的可移动且不可复制性。不
可复制保性证了在同一时间点，一个 std::thread 实例只能关联一个执行线程；可移动性使得
程序员可以自己决定，哪个实例拥有实际执行线程的所有权。

##2.3 转移线程所有权



##3.3 使用互斥量保护共享数据

#### C++11 std::unique_lock与std::lock_guard区别及多线程应用实例
https://blog.csdn.net/tgxallen/article/details/73522233
#### std :: defer_lock，std :: try_to_lock，std :: adopt_lock
它们用于为std :: lock_guard，std :: unique_lock 和std :: shared_lock指定锁定策略。
https://en.cppreference.com/w/cpp/thread/lock_tag



##4.1 等待一个事件或者其他条件
###4.2.2 std::packetask<>
std::packaged_task介绍及使用
https://blog.csdn.net/godmaycry/article/details/72868559

一、std::packaged_task简介
在上一篇，我们介绍了std::promise的使用方法，其实std::packaged_task和std::promise非常相似，简单来说std::packaged_task<F>是对std::promise<T= std::function<F>>中T= std::function<F>这一可调对象(如函数、lambda表达式等)进行了包装，简化了使用方法。并将这一可调对象的返回结果传递给关联的std::future对象。


###4.2.3 std::promise
std::promise介绍及使用
https://blog.csdn.net/godmaycry/article/details/72844159
std::promise是C++11并发编程中常用的一个类，常配合std::future使用。其作用是在一个线程t1中保存一个类型typename T的值，可供相绑定的std::future对象在另一线程t2中获取

promise是在一个线程设置数据，这个数据可以是一个任务，另外一个线程负责get_future获取数据，可以获取这个任务，但这个任务并没有执行过

paskeaged_task则传递的是一个任务，另外一个线程可以get_future直接过去任务的执行结果
