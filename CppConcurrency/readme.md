《Cpp Concurrency In Action》

本书相关
github 翻译地址：https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action
gitbook 在线阅读：http://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/
书中源码：https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action
学习C++11/14: http://www.bogotobogo.com/cplusplus/C11

# 1

## 1.1
什么是并发
并发的途径  进程并发 线程并发

进程并发和线程并发的区别

## 1.2 为什么使用并发

主要原因有两个：关注点分离(SOC)和性能。事实上，它们应该是使用并发的唯一原因；如果
你观察得足够仔细，所有因素都可以归结到其中的一个原因(或者可能是两个都有。当然，除
了像“就因为我愿意”这样的原因之外)。

## 1.2 为什么不使用并发
基本上，不使用并发的唯一原因就是，收益比不上成本


## 1.4 入门



##2.1.1
启动了线程，你需要明确是要等待线程结束(加入式――参见2.1.2节)，还是让其自主运行(分
离式――参见2.1.3节)。如果 std::thread 对象销毁之前还没有做出决定，程序就会终止
( std::thread 的析构函数会调用 std::terminate() )。因此，即便是有异常存在，也需要确保
线程能够正确的加入(joined)或分离(detached)。2.1.3节中，会介绍对应的方法来处理这两种
情况。需要注意的是，必须在 std::thread 对象销毁之前做出决定，否则你的程序将会终止
(std::thread的析构函数会调用std::terminate()，这时再去决定会触发相应异常)。

##2.1.3

##2.1.4

通常称分离线程为守护线程(daemon threads),UNIX中守护线程是指，没有任何显式的用户接
口，并在后台运行的线程。这种线程的特点就是长时间运行；线程的生命周期可能会从某一
个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结
构进行优化。另一方面，分离线程的另一方面只能确定线程什么时候结束，发后即忘(fire and
forget)的任务就使用到线程的这种方式


这个例子也展示了传参启动线程的方法：不仅可以向 std::thread 构造函数①传递函数名，还
可以传递函数所需的参数(实参)。C++线程库的方式也不是很复杂。当然，也有其他方法完成
这项功能，比如:使用一个带有数据成员的成员函数，代替一个需要传参的普通函数。

##2.2 线程传参


期望传递一个引用，但整个对象被复制了

标准线程库中和 std::unique_ptr 在所属权上有相似语义类型的类有好几种， std::thread 为
其中之一。虽然， std::thread 实例不像 std::unique_ptr 那样能占有一个动态对象的所有
权，但是它能占有其他资源：每个实例都负责管理一个执行线程。执行线程的所有权可以在
多个 std::thread 实例中互相转移，这是依赖于 std::thread 实例的可移动且不可复制性。不
可复制保性证了在同一时间点，一个 std::thread 实例只能关联一个执行线程；可移动性使得
程序员可以自己决定，哪个实例拥有实际执行线程的所有权。

##2.3 转移线程所有权

